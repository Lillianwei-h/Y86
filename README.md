# Y86-SEQ 报告
宋文彦 韩偲蔚 许资音
## 运行方法
1. 在ourCode目录下运行runner_io.py，输入需要运行的.yo文件，注意要在回车后输入文件路径，而不是使用`<`来重定向输入
2. 使用live-server插件（可以直接安装，参考：https://www.npmjs.com/package/live-server ，但更推荐在vsCode里下载live-server插件）
3. 针对第一种方法：在ourCode/web-design目录下运行live-server，即可自动在浏览器中打开前端页面
4. 针对第二种方法：在vsCode里打开ourCode/web-design/index.html，右键运行“Open with Live Server”，即可自动在浏览器中打开前端页面
5. 点击页面上大标题开始运行
6. 如果后端重新运行生成新文件，前端无需刷新，按下大标题即开始新的输出

## 后端
### 总览

分为四大板块：运行文件，CPU及其关键部件模拟，单周期CPU运行的六大阶段，通用常数和函数。  

1. 运行文件：`runner.py`（测试准确性用）/`runner——io.py`（前端用）
2. 部件模拟：`CPU.py`, `Registers.py`, `Memory.py`
3. 单周期CPU运行的六大阶段：`phases_fetch.py`, `phases_decode.py`, `phases_execute.py`, `phases_memory.py`, `phases_writeback.py`, `phases_updatePC.py`  
4. 通用常数和函数：`const.py`, `general_funcs.py`

### 运行文件 runner.py（测试准确性用）

1. 将所有测试样例读入，组成一个数组。在该数组内循环，完成所有的测试。
2. 每个测试中有多条汇编代码+汇编解释（以`｜`分开）
3. 根据Y86背景知识可知，每条语句都要经历6个阶段（取指、解码、执行、访存、写回、更新PC）。将这六个阶段写成一个函数`run`，采用一个循环逐步完成这六个步骤，循环结束的条件是CPU的状态码不是`SAOK`（即非正常运行）。
4. 最后将CPU日志按json格式进行输出。

### 运行文件 runner_io.py（前端用）
1. 重定向输入
2. 输出文件为ourCode/web-design/answer.json

### 通用常数和函数

1. 依据《CSAPP · Y86的顺序实现》一章中的内容，将所有的寄存器、指令都与其相关十六进制代码相关联起来，其余所有后端代码文件都会引用该文件。
2. 将写后端代码期间遇到的一些常用的操作编为函数并汇总到一个文件中，其余所有后端代码都会引用该文件。包括十六进制与十进制在多种变量类型之间转换、分割字符串、转换存储模式（小端 & 大端）。
3. 详细的代码实现原理在代码包中有注释。

### 部件模拟

#### CPU：

1. 用类实现对Y86 CPU的模拟，包括寄存器对象、内存对象、条件码对象、程序状态码以及六大阶段中会使用到的任何变量信息。
2. 设有初始化、获取CPU状态、改变程序状态码、获取程序状态码的接口。

#### Register：

1. 用类模拟Y86 寄存器。
2. 采用列表形式存储，每个寄存器包含8个字（每个字2bits），组成一个16个字符的字符串，共15个寄存器（编号为0x0 ~ 0xe）。全部初始化为0
3. 包含读寄存器、写寄存器、返回所有寄存器信息这三个接口。

#### Memory：

1. 用类模拟Y86的内存。

2. 采用字符串形式储存，2bits为一字（一单位），全初始化为0。
3. 包含读内存、写内存、读取并储存指令、返回内存信息（按照8字节对齐，返回十进制对应值，当且仅当非0时返回）这些接口。

### 六大阶段

六大阶段基本按照《CSAPP · Y86的顺序实现》一章进行编写。

#### 取指 Fetch：

按照各指令的类型（第一字节的内容）决定后续取指长度、该指令是否需要读写寄存器或内存等。

#### 译码 Decode：

根据取指阶段所得的`icode`设置读、写内存或寄存器的地址（dstE除外），（若有）读取寄存器。

#### 执行 Execute：

根据前两个阶段所得到的信息进行ALU运算。

将涉及到的ALU运算及其相关内容编写成函数，包括：二进制与有/无符号整型的相互转换，加法、减法、与、或运算。基本都采用列表形式实现，对于ALU的加、减、与、或运算，根据最终的运算结果设置条件码（ZF、SF、OF）。

根据前两个阶段取得的指令信息进行分情况讨论、运算。对于条件跳转类的指令，根据ALU运算结果设置Cnd。由于dstE（写回步骤中要用到的，写回的目标寄存器的地址）涉及到条件跳转类的指令，在判断完Cnd之后设置dstE。Y86所有支持的指令中，注意到CMOVQ和IRRMOVQ的icode（指令第一字节的第一个bit）是相同的（都是2），因此在判断指令是否为条件判断时，判断icode是否为`IJXX`或`IRRMOVQ`，对于后方的ifun又进行了分类讨论。

#### 访存 Memory：

根据第一、二阶段获得的icode判断是否需要读/写内存，设置标志变量，然后根据前三个阶段读取对应的内存块。

#### 写回 Writeback：

根据前几步中的dstE和dstM以及对应的valE和valM写入寄存器。

#### 更新PC updatePC：

根据指令类型（icode）来更新下一个PC，对于跳转指令需要结合Cnd的结果一并判断是否需要跳转，若要跳转，将PC更新为valC，否则为valP。

## 前端

### index.html
网页主体 
### style/styles.css
用来美化html
### scripts/main.js
javascript文件，主要使用jquery库和其中的ajax工具来输出数据到页面
### jquery/dist/jquery.js
使用的jQuery库
### answer.json
后端运行runner_io生成的结果，用来输入到前端
